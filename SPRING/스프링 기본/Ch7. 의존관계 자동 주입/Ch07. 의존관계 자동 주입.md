### 01. 다양한 의존관계 주입 방법
- ### 4가지 방법
    - **생성자 주입**
        - 빈 등록시 생성자를 호출하여야 하기 때문에 생성자 호출 시점에 의존관계가 주입된다.
        - 특징
            - 생성자 호출 시접에 딱 1번만 호출되는 것이 보장된다.
            - **불변, 필수** 의존관계에 사용 → **규약을 두는 것**
        - 생성자가 딱 1개만 있을 시 **@Autowired 생략 가능**
    - **수정자 주입(setter 주입)**
        - setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계 주입하는 방법
        - setter 메서드 에 @Autowired 추가
        - 특징
            - **선택, 변경 가능성이 있는 의존관계** 에 사용
            - 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.
    - **필드 주입**
        - 필드에 바로 주입하는 방법
            - ``` java
                @Autowired
                private MemberRespository memberRepository;
        - 특징
            - 코드가 간결하다. 
            - 외부에서 변경이 불가능하다.
                - 테스트 하기 힘들다는 치명적인 단점 존재
            - DI 프레임워크 없이 아무것도 할 수 없다.
            - 사용하는 경우
                - 애플리케이션의 실제 코드와 관계 없는 테스트 코드
                - 스프링 설정 코드 - @Configuration
    - **메서드 주입**
        - 일반 메서드를 통해서 주입
        - 특징
            - 한번에 여러 필드를 주입 받을 수 있다.
            - 잘 사용하지 않는다.
        
### 02. 옵션 처리
- ### 자동 주입 대상을 옵션으로 처리하는 방법
    - @Autowired(required=false) 
        - 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨
    - @Nullable 
        - 자동 주입할 대상이 없으면 null이 입력된다.
    - Optional<> 
        - 자동 주입할 대상이 없으면 Optional.empty 가 입력된다.
        
        
### 03. 생성자 주입을 선택해라
- ### 최근 DI 프레임워크 대부분이 생성자 주입을 권장한다.
    - **불변**
        - 대부분의 의존관계 주입은 한번 일어나면, 애플리케이션 종료시점 까지 의존관계를 변경할 일이 없다.
        - 수정자 주입을 사용하면,
            - set 메서드를 public 으로 열어두어야 한다.
    - **누락**
        - 프레임워크 없이 순수한 자바 코드를 단위 테스트 하는 경우
            - 생성자 주입 사용시 주입 데이터를 누락했을 경우 컴파일 오류 발생
    - **final 키워드**
        - 생성자 주입을 사용하면 필드에 final 키워드 사용
            - 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다. 
    
### 04. 롬복과 최신 트랜드
- ### @RequiredArgsConstructor
    - final이 붙은 필드를 모아서 생성자를 자동생성

### 05. 조회 빈이 2개 이상 - 문제
- ### 의존관계 자동 주입에서 해결하는 여러가지 방법 존재.
    - 하위 타입으로 지정 시 DIP를 위배 및 유연성 하락
    
### 06. @Autowired 필드 명, @Qualifier, @Primary
- ### 조회 대상 빈이 2개 이상일 때 해결 방법
    - **@Autowired 필드 명 매칭**
        - 필드 명을 빈 이름으로 변경
            - ``` java 
                @Autowired
                private DiscoutPolicy rateDiscountPolicy
        - 방법
            - 1. 타입 매칭
            - 2. 타입 매칭의 결과가 2개 이상일 때 필드 명, 파라미터 명으로 빈 이름 매칭
    - **@Qualifier → @Qualifier 끼리 매칭 → 빈 이름 매칭**
        - 추가 구분자를 붙여주는 방법
        - 주입시 추가적인 방법을 제공하는 것이지 빈 이름을 변경하는 것은 아니다.
        - 정리
            - 1. @Qualifier끼리 매칭
            - 2. 빈 이름 매칭
            - 3. NoSuchBeanDefinitionException 예외 발생
    - **@Primary 사용**
        - 우선순위를 지정하는 방법
        - 자주 사용 된다.
        
- ### @Primary, @Qualifier 사용
    - 메인 데이터 베이스의 커넥션을 획득하는 스프링 빈은 @Primary 를 적용해서 조회하는 곳에서 @Qualifier 지정 없이 편리하게 조회
    - 서브 데이터베이스 커넥션 빈을 획득할 때는 @Qualifier 를 지정해서 명시적으로 획득 하는 방식으로 사용하면 코드를 깔끔하게 유지
    
- ### 우선순위
    - @Primary 는 기본값 처럼 동작하는 것이고, @Qualifier 는 매우 상세하게 동작한다. 
    - @Qualifier 가 우선순위
    
### 07. 애노테이션 직접 만들기
- 여러 애노테이션을 모아서 사용하는 기능은 스프링이 지원하는 것
    - 상속이라는 개념이 없다.
- 여러 애노테이션을 조합하여 사용할 수 있다.
    - 무분별하게 생성하는것은 유지 보수에 안좋다.
    
### 08. 조회한 빈이 모두 필요할 때, List, Map
- ### 하위 타입의 스프링 빈이 모두 다 필요한 경우
    - 유연한 전략 패턴 사용 가능
    
### 09. 자동, 수동의 올바른 실무 운영 기준
- ### 편리한 자동 기능을 기본으로 사용하자
    - 빈 등록 및 의존성 주입 방법
        - 수동으로 설정 정보를 통해서 빈 등록 및 의존관계를 수동으로 주입
        - 컴포넌트 스캔과 자동 주입을 사용
    - 설정 정보를 기반으로 애플리케이션을 구성하는 부분과 실제 동작하는 부분을 명확하게 나누는 것이 이상적
        - 하지만, @Component 만 넣어주면 끝나는 일이므로 편리하게 자동 주입을 사용하자
        - 결정적으로 OCP, DIP 를 지킬 수 있다.
- ### 수동 빈 등록은 언제가 좋을까?
    - 애플리케이션은 크게 업무 로직과 기술 지원 로직으로 나눌 수 있다.
        - 업무 로직 빈(자동 기능 적극 사용): 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지토리등이 모두 업무 로직이다. 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.
        - 기술 지원 빈(수동 빈 등록을 사용): 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공통 로그 처리 처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들이다
    
- ### 비즈니스 로직 중에서 다형성을 적극 활용할 때
    - 이런 경우 수동 빈으로 등록하거나 또는 자동으로하면 특정 패키지에 같이 묶어두는게 좋다! 
    - 핵심은 딱 보고 이해가 되어야 한다!
    
- ### 정리
    - 편리한 자동 기능을 기본으로 사용하자
    - 직접 등록하는 기술 지원 객체는 수동 등록
    - 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자
